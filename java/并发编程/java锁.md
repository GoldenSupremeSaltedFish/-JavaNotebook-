### synchronized关键字（保证任意时刻，只有一个线程能执行该方法）

##### synchronized在经过优化之后属于可重入锁（重入的为计数器++）

同步会带来一定的性能开销，因此需要合理使用。不应将整个方法或者更大范围的代码块做同步，而应尽可能地缩小同步范围。

在 JVM 的早期版本中，synchronized 是重量级的，因为线程阻塞和唤醒需要操作系统的介入。但在 JVM 的后续版本中，对 synchronized 进行了大量优化，如偏向锁、轻量级锁和适应性自旋等，所以现在的 synchronized 并不一定是重量级的，其性能在许多情况下都很好，可以大胆地用。

### java中的锁（锁的类型以及锁的升级和降级（升级简单降级困难））

偏向锁：

特点：当一个线程获取锁时，如果没有其他线程竞争，该锁会偏向于这个线程，减少获取锁的开销。

适用场景：适用于线程竞争较少的场景。

轻量级锁：

特点：当有其他线程竞争时，偏向锁会升级为轻量级锁，使用自旋锁来避免线程阻塞。

适用场景：适用于短时间内锁竞争不激烈的场景。

重量级锁：

特点：当锁竞争激烈时，轻量级锁会升级为重量级锁，线程会被阻塞，直到获取到锁。

适用场景：适用于高并发场景，确保线程安全。

#### ReentrantLock（可重入锁）：

特点：提供了更多的锁控制功能，如公平锁和非公平锁、可中断锁等。

适用场景：需要更灵活的锁控制时使用。

#### ReentrantReadWriteLock（读写锁）：

特点：分为读锁和写锁，读锁可以被多个线程同时持有，而写锁是独占的。

适用场景：读多写少的场景，提高并发性能。

#### StampedLock：

特点：提供了乐观读、悲观读和写锁三种模式，适合读多写少的场景。

适用场景：需要高性能读操作的场景。

#### synchronized：

（在jvm中进行了锁的粗化，比如将多个锁的操作进行合并）

特点：Java 内置的隐式锁，使用方便，但功能相对简单。

适用场景：简单的同步需求。
CAS（Compare-And-Swap）：

特点：一种无锁的并发机制，通过比较和交换操作来实现线程安全。（aba问题，对于一个变量的多次改变也是无法进行识别的）

适用场景：高性能并发场景。

java中锁升级的机制
  
#### 锁升级的具体过程（无锁状态-偏向锁状态-轻量级锁状态-重量级锁状态）（锁竞争的状态）

#### 偏向锁（一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID。当下次该线程进入这个同步块时，会去检查锁的 Mark Word 里面是不是放的自己的线程 ID。）

偏向锁撤销和偏向锁释放是两码事

##### 撤销：笼统的说，就是多个线程竞争导致不能再使用偏向模式，主要是告知这个锁对象不能再用偏向模式（转化为轻量级锁）

方法（
在这个安全点，线程可能还是处在不同的状态，先说结论（因为源码就是这么写的）

线程不存活，或者活着的线程退出了同步块，很简单，直接撤销偏向就好了

活着的线程但仍在同步块之内，那就升级成轻量级锁
）

##### 释放：和你的常规理解一样，对应的就是 synchronized 方法的退出或 synchronized 块的结束

#### 批量重偏向（分为两道底线）

这是第一种场景的快速解决方案，以 class 为单位，为每个 class 维护一个偏向锁撤销计数器，只要 class 的对象发生偏向撤销，该计数器 +1，当这个值达到重偏向阈值（默认 20）时

JVM 就认为该 class 的偏向锁有问题，因此会进行批量重偏向, 它的实现方式就用到了我们上面说的 epoch

第二个底线（）

当达到重偏向阈值后，假设该 class 计数器继续增长，当其达到批量撤销的阈值后（默认 40）时，

JVM 就认为该 class 的使用场景存在多线程竞争，会标记该 class 为不可偏向。之后对于该 class 的锁，直接走轻量级锁的逻辑。

#### 头部存了一个字段用来说明谁拿到了这个线程

偏向锁升级为轻量级锁：

当一个线程持有偏向锁时，如果有其他线程尝试获取该锁，JVM 会撤销偏向锁，将其升级为轻量级锁。这个过程会导致短暂的“Stop The World”操作。

轻量级锁升级为重量级锁：

如果轻量级锁的自旋等待失败，即多个线程竞争同一个锁且自旋次数超过一定阈值，锁会升级为重量级锁。此时，未获取到锁的线程会被阻塞，直到锁被释放。

重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU

#### 重量级锁和Object.wait，wait方法直接为重量级锁

#### 锁的降级（条件苛刻）
