### 线程的六种状态

#### NEW（线程尚未启动，但是已经被创建了）

反复调用同一个线程的 start 方法是否可行？

假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start 方法是否可行？

在start()内部，有一个 threadStatus 变量。如果它不等于 0，调用start()会直接抛出异常。

##### 都不行，在调用 start 之后，threadStatus 的值会改变（threadStatus !=0），再次调用 start 方法会抛出 IllegalThreadStateException 异常。
##### threadStatus 为 2 代表当前线程状态为 TERMINATED（下面会讲）

#### RUNNABLE
表示当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。

#### BLOCKED
阻塞状态。处于 BLOCKED 状态的线程正等待锁的释放以进入同步区。

#### WAITING+TIMED_WAITING
等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。

调用下面这 3 个方法会使线程进入等待状态：

Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；（换新为nodify）

Thread.join()：等待线程执行完毕，底层调用的是 Object 的 wait 方法；

LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。

#### 线程中断

在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在 Java 里还没有安全方法来直接停止线程，但是 Java 提供了线程中断机制来处理需要中断线程的情况。

线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理



### 线程需要的成分（一个健全的线程需要的）

首先是合适的中断机制：在合适的地方加入中断监测点

合适的锁

记得释放资源（释放的时候也要考虑资源的复用：不过这部分已经被框架进行完善了）
