### 1.Java面向什么？

面向对象，面向对象和面向过程的区别

### 2.jvm内存区域有哪些
线程私有区域【程序计数器、 虚拟机 栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存

### 3.jvm运行时内存

### 4.垃圾回收的算法有哪些

标记-回收，复制算法，以及标记-整理算法

优缺点

复制较慢但是
分代回收机制，老年代和年轻代（这是机制）

full gc
### 5.Java中四种引用类型
？不知道

### 6.gc垃圾回收器有哪些
不知道

### 7. io与nio的不同之处
nio是非阻塞io

8.Java的类加载机制

### 9. 详细说明双亲委派机制
类的加载往往会被委派给父类，作用是防止对基类的恶意篡改
### 10.tomcat是如何打破双亲委派机制的

Tomcat是一个Web框架，并且可以支持部署多个web项目，web项目在Tomcat被抽象的称为Context，即每一个web项目是一个Context。而每个Context是独立的，比如项目A可以引用spring1.0，而项目B可以引用spring2.0版本，如果是双亲委派机制，那么只能存在一个spring版本。Tomcat是如何打破双亲委派机制的呢？



### 11.List中Vector ArrayList LinkedList底层实现分别是什么

arraylist

### 12.HashSet TreeSet LinkedHashSet的底层是是什么

### 13.CurrentHashMap 是如何实现线程安全的
在每次插入时都会引入cas机制来保持数据的一致性
### 14. 有哪些创建线程的方式
new一个线程，
### 15.四种线程池分别是什么

### 16.线程的生命周期是什么

### 17.如何终止线程
### 18.sleep和wait有何区别
所属类和调用方式：

sleep 方法属于 Thread 类，可以在任何地方调用。

wait 方法属于 Object 类，必须在同步块或同步方法中调用。

对锁的处理机制：

sleep 方法不会释放锁，线程只是暂停执行一段时间，但仍然持有锁
。
wait 方法会释放锁，让出 CPU 资源，并且线程进入等待状态，直到被其他线程唤醒。

唤醒机制：

sleep 方法在指定的时间后会自动苏醒，不需要其他线程唤醒。

wait 方法需要被 notify 或 notifyAll 方法唤醒。

### 19.start和run 有何区别（start会生成一个新的线程，而run不会，也不会导致上下文的切换）
run 方法：

run 方法是 Thread 类的一个普通方法，用于定义线程的主体逻辑。

当直接调用 run 方法时，它会在当前线程的上下文中执行，而不会创建新的线程。

直接调用 run 方法不会实现多线程的并发执行，只是在当前线程中按顺序执行 run 方法的内容。

### 20.Java中有哪些锁机制
自旋锁，轻量级锁，重量级锁
##### synchronized 锁：
隐式锁：通过 synchronized 关键字实现，分为方法锁和代码块锁。它是 JVM 层面实现的锁，使用方便，但性能相对较低。

对象锁：锁住的是具体的对象实例。

类锁：锁住的是类对象，通常用于静态方法。


显式锁（Lock）：

ReentrantLock：可重入锁，支持公平锁和非公平锁，提供了更灵活的锁机制。

ReentrantReadWriteLock：读写锁，允许多个读线程同时访问，但写线程独占。

StampedLock：改进的读写锁，提供了乐观读锁，性能更高。

### 21.synchronize的作用和核心实现分别是什么

### 22.线程中有什么方法

### 23.线程上下文是如何切换的

### 24.什么是CAS，什么是AQS

cas是通过判断事务提交之前之后的版本号来辨别信息是否经过修改


### 25.JAVA异常的分类，分别举出有哪些常见的异常

#### 系统錯误（system error) 是由 Java 虚拟机抛出的，用 Error 类表示。Error 类描述的是内部系统错误。这样的错误很少发生。如果发生，除了通知用户以及尽量稳妥地终止程序外，几乎什么也不能做

#### Exception 则是编译时异常，它可以被捕获并处理。

某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：

NumberFormatException ：数值类型的格式错误；

FileNotFoundException ：未找到文件；

SocketException ：读取网络失败。

还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：

NullPointerException ：对某个 null 的对象调用方法或字段；

IndexOutOfBoundsException ：数组索引越界。

 RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类，可能在执行方法期间抛出但未被捕获的 RuntimeException 的任何子类都无需在 throws 子句中进行声明，指的就是这些问题不需要提前被预防（本质上也可以的，只不过没必要），因为只有在真正运行的时候才能发现是否发生问题，一旦在运行期间发生了问题，则一般不会修正，程序直接终端

可捕获异常和不可捕获异常（exception）

可捕获异常（Checked Exception）


定义：必须在编译时处理的异常。

处理方式：必须使用try-catch块捕获或在方法签名中使用throws声明。

常见例子：IOException、SQLException。

用途：通常用于表示程序外部的错误，如文件未找到、数据库连接失败等。

不可捕获异常（Unchecked Exception）

定义：在编译时不强制处理的异常。

处理方式：可以选择捕获，也可以不处理。

常见例子：NullPointerException、ArrayIndexOutOfBoundsException。

用途：通常用于表示程序内部的逻辑错误，如空指针访问、数组越界等。

error（出现了则编译都过不去）

### 26. Java中反射有什么作用，好处是什么

可以动态的获取类内部的内容，好处是可以减少代码量以及

### 27.Java中注解是如何使用的，自己写过注解吗
写过，自动装配注解

注解的使用
### 28.内部类是什么
类中有类

成员内部类：定义在另一个类的内部，作为该类的成员。成员内部类可以访问外部类的所有成员变量和方法，包括私有成员。

局部内部类：定义在方法或代码块内部，仅在该方法或代码块中可见。

静态内部类：使用 static 修饰的内部类。静态内部类不依赖于外部类的实例，可以直接创建对象。

匿名内部类：没有名字的内部类，通常用于简化代码，特别是在实现接口或继承类时。

### 29.泛型是什么

类型参数化：泛型允许在类、接口和方法中使用类型参数。例如，ArrayList<T> 中的 T 就是一个类型参数，可以在实例化时指定具体的类型，如 ArrayList<String>。
类型安全：使用泛型可以在编译时进行类型检查，避免了运行时的类型转换异常。例如，ArrayList<String> 只能存储字符串，编译器会在添加非字符串元素时报错。

### 30.Java序列化的目的
序列化是什么，类toio流，目的是进行网络传输，保存在磁盘

序列化的方法
### 31.cookie和session是什么意思，分别有什么作用
cookie和session都是一种令牌，cookie是在浏览器中保存用户登录信息
session一般是服务器？？（需要精进）
### 32.转发和重定向有什么区别
不知道

### 34.spring有什么特点
工厂化，将类的创建和创建方法进行分离
依赖的统一管理
### 35.spring的核心组件有哪些，你用过哪些常用模块，包，和注解



### 36.spring ioc的原理





### 37.spring bean的作用域，生命周期以及依赖注入的四种方式



### 38.spring aop是神马意思
面向切面编程
提供面向切面编程功能，允许将横切关注点（如事务管理、日志记录）与业务逻辑分离。

39.springmvc的工作流程
40.springboot的原理（？？？我有点蒙蔽或许这题想问什么是springboot？）
