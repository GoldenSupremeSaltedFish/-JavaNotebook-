### 尽量用单表操作，复杂的业务逻辑交给java

多表链接十分难以优化

## 接下来就是锁的机制了（锁本身也是一个数据结构）

innodb中锁的机制（也只有这个引擎才支持行级别锁）

那么我们在操作一个事务的时候，如果对应多条记录，是不是要针对多条记录生成多个内存的锁结构呢？比如我们执行select * from tb_user for update的时候，tb_user表中如果存在1万条数，那么难道要生成1万个内存的锁结构吗？那当然不会是这样的。其实，如果符合以下几个条件，那么这些记录的锁就可以放到一个内存中的锁结构里了，条件如下所示：

加锁操作时在同一个事务中
需要被加锁的记录在同一个页中
需要加锁的类型是一致的
锁的等待状态是一致的


## 分类

乐观锁（cas，aba问题），悲观锁

读锁s，写锁x（全局锁）（开销起飞）（使用场景，全库备份）

表锁、行锁、意向锁、间隙锁

(1)、对于表锁，主要是来记录对哪张表进行的加锁操作以及其他的信息。（innodb的mvcc是通过行锁来进行多版本并发控制的）

哪些命令会触发表锁：alter table（增加列删除列）

drop table truncate table（删除数据）

lock table（显式的加锁）




(2)、对于行锁，内容包括3部分：

Space ID：记录所在的表空间ID。

Page Number：记录所在的页号。

n_bits：一条记录对应一个bit


type_mode

它是由32个bit组成的，分别为：lock_mode、lock_type（锁的类型）、lock_wait（是否等待）和rec_lock_type

## lock_type（行锁的类型）

共享锁（s）

  

排他锁（x）


单行操作（性能好，锁越短越好）

## 举个栗子

现在要查询主键（根据主键加锁）（聚簇索引）

例如
```
update user set age = 10 where id = 49;//其中id是自增主键 

```
如果存在这个id，那么就加标准记录锁，如果对应的值不存在，就在id所在的索引间隙增加间隙锁

基于主键（聚簇索引）进行范围查询时，采用采用Next Key Lock添加行锁

### 根据二级索引加锁 

先进行二级索引的查询：然后将
