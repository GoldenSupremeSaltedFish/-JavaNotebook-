### 1.RabbitMQ是什么？ 
RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。

PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件

### 2.RabbitMQ特点? 
可靠性: RabbitMQ使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。

灵活的路由 : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。

扩展性: 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。

高可用性 : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。

多种协议: RabbitMQ除了原生支持AMQP协议，还支持STOMP， MQTT等多种消息 中间件协议。

多语言客户端 :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。

管理界面 : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。

插件机制 : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。

### 3.AMQP协议3层？ 
Module Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。

Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。

TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。

### 5.AMQP模型的几大组件？ 

交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。

队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。

绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列

### 6.说说Broker服务节点、Queue队列、Exchange交换器？ 

Broker可以看做RabbitMQ的服务节点。一般请下一个Broker可以看做一个RabbitMQ服务器。

Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。

Exchange:生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。

### 7.消息队列有什么优缺点 
优点是在特殊场景下有其对应的好处，解耦、异步、削峰。缺点有以下几个：

系统可用性降低 系统引入的外部依赖越多，越容易挂掉。

系统复杂度提高 硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？

### 8.如何保证消息的可靠性？ 
消息到MQ的过程中搞丢，MQ自己搞丢，MQ到消费过程中搞丢。

生产者到RabbitMQ：事务机制和Confirm机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。

RabbitMQ自身：持久化、集群、普通模式、镜像模式。

RabbitMQ到消费者：basicAck机制、死信队列、消息补偿机制。

#### 事务机制

在 RabbitMQ 中，事务是基于通道（Channel）来实现的。一个事务通道用于保证在该通道上发布的消息和确认的消息操作要么全部成功，要么全部失败。

RabbitMQ 的事务机制可以确保消息在复杂操作中的一致性和可靠性，但使用时需要考虑性能开销。对于大多数应用场景，Publisher Confirms 机制可能是更高效的选择，而事务机制则适用于需要严格一致性的场景。

#### Confirm机制（生产者确认机制）

启用生产者确认模式

生产者确认机制是通过将通道（Channel）设置为确认模式来启用的。调用 confirmSelect 方法后，通道进入确认模式。

##### 处理确认和未确认响应

生产者可以通过回调函数来处理 RabbitMQ 的 ack 或 nack 响应。
可以设置单个确认（Single Confirm）或批量确认（Batch Confirm），以提高效率。
启用后，每个发布的消息都会被分配一个唯一的 delivery tag，用于标识该消息。

### RabbitMQ自身：持久化、集群、普通模式、镜像模式。

#### 持久化：交换器的持久化，队列的持久化，消息的持久化。

#### 集群模式
（主备模式：主节点如果挂了，从节点提供服务而已，和activemq利用zookeeper做主/备一样）兔子窝模式

镜像模式

镜像模式：集群模式非常经典的就是Mirror镜像模式，保证100%数据不丢失，在实际工作中用的最多的。

多活模式

多活模式：这种模式也是实现异地数据复制的主流模式，因为Shovel模式配置比较复杂，所以一般来说实现异地集群都是使用双活或者多活模式来实现的。这种模式需要依赖rabbitmq的federation插件，可以实现继续的可靠AMQP数据通信，多活模式在实际配置与应用非常的简单。

### RabbitMQ到消费者：basicAck机制、死信队列、消息补偿机制。

### 消费者确定机制

### 死信队列

“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：

消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue 属性被设置为false。

消息在队列的存活时间超过设置的TTL时间。

消息队列的消息数量已经超过最大队列长度。

那么该消息将成为“死信”。

#### 如何配置死信对列

配置业务队列，绑定到业务交换机上

为业务队列配置死信交换机和路由key

为死信交换机配置死信队列

并不是直接声明一个公共的死信队列，然后所以死信消息就自己跑到死信队列里去了。而是为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然后为每个业务队列分配一个单独的路由key。
#### 意义

业务消息十分重要，不能进行丢弃
#### 死信如何处理
重新投递（后续的逻辑代码）

### 消息补偿机制

消息补偿机制核心 : 发现未成功消费的消息, 并且重新发送消息

消息补偿机制需要建立在业务数据库和MQ数据库的基础之上 , 当我们发送消息时 , 需要同时将消息数据保存在数据库中, 两者的状态必须记录。

### 9.什么是RoutingKey路由键？ 

生产者将消息发送给交换器的时候，会指定一个RoutingKey,用来指定这个消息的路由规则，这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。

### 10.Binding绑定？ 
通过绑定将交换器和队列关联起来，一般会指定一个BindingKey,这样RabbitMq就知道如何正确路由消息到队列了。

### 11.交换器的类型

anout:把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。

direct:把消息路由到BindingKey和RoutingKey完全匹配的队列中。

topic:
匹配规则：
RoutingKey 为一个 点号'.': 分隔的字符串。比如: java.xiaoka.show

BindingKey和RoutingKey一样也是点号“.“分隔的字符串。

BindingKey可使用 * 和 # 用于做模糊匹配，*匹配一个单词，#匹配多个或者0个

headers:不依赖路由键匹配规则路由消息。是根据发送消息内容中的headers属性进行匹配。性能差，基本用不到。

### 12.交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？

mandatory ：true 返回消息给生产者。

mandatory: false 直接丢弃。

### 13.延迟队列？ 

存储对应的延迟消息，指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费

### 14.优先级队列？ 

优先级高的队列会先被消费。

可以通过x-max-priority参数来实现。

当消费速度大于生产速度且Broker没有堆积的情况下，优先级显得没有意义。

### 15.了解Virtual Host吗? 
每一个RabbitMQ服务器都能创建虚拟的消息服务器，也叫虚拟主机(virtual host)，简称vhost。

默认为“/”。
### 16.事务机制？ 

RabbitMQ 客户端中与事务机制相关的方法有三个:

channel.txSelect  用于将当前的信道设置成事务模式。

channel . txCommit 用于提交事务 。

channel . txRollback 用于事务回滚,如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常,通过txRollback来回滚。

[继续学习][继续学习]

[继续学习]:https://cloud.tencent.com/developer/article/1816305
